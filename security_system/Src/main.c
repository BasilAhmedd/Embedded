/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

//#include <stdint.h>
//#include "stm32f401xx.h"
//int main(void)
//{
//	int sequence[4]= {0,0,0,0};
//	int corrected_sequence[4] = {1,2,3,4};
//	int current_index = 0;
//    RCC->AHB1ENR |= (1<<0); // enable GPIOA
//
//	GPIOA->MODER &= ~(0b11 << (0*2)); // first button
//
//	GPIOA->MODER &= ~(0b11 <<(1*2)); //second button
//
//	GPIOA->MODER &= ~(0b11 <<(2*2)); //third button
//
//	GPIOA->MODER &= ~(0b11 <<(3*2)); //fourth button
//
//	GPIOA->MODER &= ~(0b11 <<(4*2)); //fifth button
//
//    GPIOA->MODER &= ~(0b11 <<(10*2)); //green led
//    GPIOA->MODER |= (0b1 <<(10*2));
//
//    GPIOA->MODER &= ~(0b11 <<(14*2)); //red led
//    GPIOA->MODER |= (0b1 <<(14*2));
//
//    GPIOA->MODER &= ~(0b11 <<(15*2)); //buzzer
//    GPIOA->MODER |= (0b1 <<(15*2));
//
//    GPIOA->MODER &= ~((0b11 <<(10*2)) | (0b11 <<(14*2)) | (0b11 <<(15*2)));
//    GPIOA->PUPDR |= ((0b01 << (0*2)) | (0b01 << (1*2)) |(0b01 << (2*2))|(0b01 << (3*2))|(0b01 << (4*2)));
//    while(1){
//    	if(!((GPIOA->IDR>>4)&1)){ // reset button
//    		current_index = 0;
//    		for(int i = 0 ; i<4 ; i++){
//    			sequence[i] = 0;
//    		}
//    		GPIOA->ODR &= ~(1 <<(10*2));
//    		GPIOA->ODR &= ~(1 <<(14*2));
//    		GPIOA->ODR &= ~(1 <<(15*2));
//    	}
//
//    	for (int i =0;i<4;i++){
//    		if(!((GPIOA->IDR>>i)&1)){
//    			 sequence[current_index] = i+1;
//    			 current_index++;
//    		}
//    		while(!((GPIOA->IDR>>i)&1));
//    		if(current_index == 4){
//    			int is_correct = 1;
//    			for (int j = 0 ;j <4;j++){
//    				if(sequence[j] != corrected_sequence[j]){
//    					is_correct = 0;
//    					break;
//    				}
//    			}
//    			if(is_correct){
//    				GPIOA->ODR |= (1<<10);
//    			}else{
//    				GPIOA->ODR |= (1<<14);
//    				GPIOA->ODR |= (1<<15);
//    			}
//
//    			current_index = 0;
//    		    for (int j = 0; j < 4; j++) {
//                       sequence[j] = 0;
//    		   }
//    		}
//    	}
//    }
//
//}

//#include <stdint.h>
//#include "stm32f401xx.h"
//
//int main(void) {
//    int sequence[4] = {0, 0, 0, 0};
//    int correct_sequence[4] = {1, 2, 3, 4};
//    int current_index = 0;
//
//    RCC->AHB1ENR |= (1 << 0); // Enable GPIOA clock
//
//    // Configure buttons as input with pull-up resistors
//    for (int i = 0; i < 5; i++) {
//        GPIOA->MODER &= ~(0b11 << (i * 2));
//        GPIOA->PUPDR |= (0b01 << (i * 2)); // Pull-up resistors
//    }
//
//    // Configure green LED as output
//    GPIOA->MODER &= ~(0b11 << (10 * 2));
//    GPIOA->MODER |= (0b01 << (10 * 2));
//
//    // Configure red LED as output
//    GPIOA->MODER &= ~(0b11 << (14 * 2));
//    GPIOA->MODER |= (0b01 << (14 * 2));
//
//    // Configure buzzer as output
//    GPIOA->MODER &= ~(0b11 << (15 * 2));
//    GPIOA->MODER |= (0b01 << (15 * 2));
//
//    while (1) {
//        // Check if the reset button is pressed
//        if (!((GPIOA->IDR >> 4) & 1)) {
//            current_index = 0;
//            for (int i = 0; i < 4; i++) {
//                sequence[i] = 0;
//            }
//            GPIOA->ODR &= ~(1 << 10); // Turn off green LED
//            GPIOA->ODR &= ~(1 << 14); // Turn off red LED
//            GPIOA->ODR &= ~(1 << 15); // Turn off buzzer
//        }
//
//        // Check if any of the first four buttons are pressed
//        for (int i = 0; i < 4; i++) {
//            if (!((GPIOA->IDR >> i) & 1)) {
//                sequence[current_index] = i + 1;
//                current_index++;
//                while (!((GPIOA->IDR >> i) & 1)); // Wait for button release
//                if (current_index == 4) {
//                    int is_correct = 1;
//                    for (int j = 0; j < 4; j++) {
//                        if (sequence[j] != correct_sequence[j]) {
//                            is_correct = 0;
//                            break;
//                        }
//                    }
//
//                    if (is_correct) {
//                        GPIOA->ODR |= (1 << 10); // Turn on green LED
//                    } else {
//                        GPIOA->ODR |= (1 << 14); // Turn on red LED
//                        GPIOA->ODR |= (1 << 15); // Turn on buzzer
//                    }
//
//                    current_index = 0;
//                    for (int j = 0; j < 4; j++) {
//                        sequence[j] = 0;
//                    }
//                }
//            }
//        }
//    }
//}




#include <stdint.h>
#include "stm32f401xx.h"

int main(void) {
    int sequence[4] = {0, 0, 0, 0};
    int correct_sequence[4] = {1, 2, 3, 4};
    int current_index = 0;

    RCC->AHB1ENR |= (1 << 0); // Enable GPIOA clock

    // Configure buttons as input with pull-up resistors
    for (int i = 0; i < 5; i++) {
        GPIOA->MODER &= ~(0b11 << (i * 2));
        GPIOA->PUPDR |= (0b01 << (i * 2)); // Pull-up resistors
    }

    // Configure green LED as output
    GPIOA->MODER &= ~(0b11 << (10 * 2));
    GPIOA->MODER |= (0b01 << (10 * 2));

    // Configure red LED as output
    GPIOA->MODER &= ~(0b11 << (11 * 2));
    GPIOA->MODER |= (0b01 << (11 * 2));

    // Configure buzzer as output
    GPIOA->MODER &= ~(0b11 << (15 * 2));
    GPIOA->MODER |= (0b01 << (15 * 2));

    while (1) {
        // Check if the reset button is pressed
        if (!((GPIOA->IDR >> 4) & 1)) {
            current_index = 0;
            for (int i = 0; i < 4; i++) {
                sequence[i] = 0;
            }
            GPIOA->ODR &= ~(1 << 10); // Turn off green LED
            GPIOA->ODR &= ~(1 << 11); // Turn off red LED
            GPIOA->ODR &= ~(1 << 15); // Turn off buzzer
        }

        // Check if any of the first four buttons are pressed
        for (int i = 0; i < 4; i++) {
            if (!((GPIOA->IDR >> i) & 1)) {
                sequence[current_index] = i + 1;
                current_index++;
                while (!((GPIOA->IDR >> i) & 1)); // Wait for button release
                if (current_index == 4) {
                    int is_correct = 1;
                    for (int j = 0; j < 4; j++) {
                        if (sequence[j] != correct_sequence[j]) {
                            is_correct = 0;
                            break;
                        }
                    }

                    if (is_correct) {
                        GPIOA->ODR |= (1 << 10); // Turn on green LED
                    } else {
                        GPIOA->ODR |= (1 << 11); // Turn on red LED
                        GPIOA->ODR |= (1 << 15); // Turn on buzzer
                    }

                    current_index = 0;
                    for (int j = 0; j < 4; j++) {
                        sequence[j] = 0;
                    }
                }
            }
        }
    }
}
