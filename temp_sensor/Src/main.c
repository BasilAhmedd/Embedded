/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f401xx.h"
int main(void)
{
	RCC->AHB1ENR |= (1<<0); // GPIOA Enable
	RCC->AHB1ENR |= (1<<1); //GPIOB Enable
	RCC->APB2ENR |= (1<<8); //ADC1 Enable

	GPIOA->MODER &= ~(0b11 << (0*2)); //Analog Input
	GPIOA->MODER |= (0b11 <<(0*2));

	GPIOA->MODER &= ~(0b11 <<(1*2)); //red led
	GPIOA->MODER |= (0b1 <<(1*2));

	GPIOA->MODER &= ~(0b11 <<(2*2)); //yellow led
	GPIOA->MODER |= (0b1 <<(2*2));

	GPIOA->MODER &= ~(0b11 <<(3*2)); //green led
	GPIOA->MODER |= (0b1 <<(3*2));

	GPIOB->MODER &= ~(0b11 <<(0*2)); //buzzer
	GPIOB->MODER |= (0b01 <<(0*2));

	GPIOB->MODER &= ~(0b11 <<(6*2));//fan
	GPIOB->MODER |= (0b01 <<(6*2));//fan

	ADC1->CR2 |= (1<<0); // enable ADC1
	for(volatile int i = 0 ;i<1000;i++);
	ADC1->CR1 |= (0 << 24); // Resolution

	ADC1->SQR3 = 0; // channel 0

    while(1){
    	ADC1->CR2 |= (1<<30); //start conversion
    	while(!(ADC1->SR & (1<<1)));//wait for conversion

    	int ADC_Read = ADC1->DR;

    	int temp = ((ADC_Read*3.3)/4096)/0.01;//4096=2^12

        if(temp <= 25){
        	   GPIOA->ODR |= (1<<3);   // Green LED ON
        	            GPIOA->ODR &= ~(1<<2);  // Yellow LED OFF
        	            GPIOA->ODR &= ~(1<<1);  // Red LED OFF
        	            GPIOB->ODR &= ~(1<<6);  // Fan OFF
        	            GPIOB->ODR &= ~(1<<0);  // Buzzer OFF
        }else if (temp>25  && temp <=35){
                   GPIOA->ODR &= ~(1<<3);
        	            GPIOA->ODR |= (1<<2);
        	            GPIOA->ODR &= ~(1<<1);
        	            GPIOB->ODR |= (1<<6);
        	            GPIOB->ODR &= ~(1<<0);

        }else if (temp > 35  && temp < 45){
                        GPIOA->ODR &= ~(1<<3);
        	            GPIOA->ODR &= ~(1<<2);
        	            GPIOB->ODR &= ~(1<<0);
        	            GPIOA->ODR |= (1<<1);
        	            GPIOB->ODR |= (1<<6);
        } if(temp >= 45){
         	   GPIOA->ODR &= ~(1<<3);
        	   GPIOA->ODR &= ~(1<<2);
        	   GPIOB->ODR &= ~(1<<6);
        	   GPIOA->ODR |= (1<<1);
        	   GPIOB->ODR |= (1<<0);
        }
    }
}
//#include "stm32f401xx.h"
//
//int main(void)
//{
//    // Enable Clocks
//    RCC->AHB1ENR |= (1<<0); // GPIOA Enable
//    RCC->AHB1ENR |= (1<<1); // GPIOB Enable
//    RCC->APB2ENR |= (1<<8); // ADC1 Enable
//
//    // Configure PA0 as Analog Input
//    GPIOA->MODER |= (0b11 << (0*2));  // Analog mode
//    GPIOA->PUPDR &= ~(0b11 << (0*2)); // No pull-up/pull-down
//
//    // Configure PA1 (Red LED) as Output
//    GPIOA->MODER &= ~(0b11 << (1*2));
//    GPIOA->MODER |=  (0b01 << (1*2));
//
//    // Configure PA2 (Yellow LED) as Output
//    GPIOA->MODER &= ~(0b11 << (2*2));
//    GPIOA->MODER |=  (0b01 << (2*2));
//
//    // Configure PA3 (Green LED) as Output
//    GPIOA->MODER &= ~(0b11 << (3*2));
//    GPIOA->MODER |=  (0b01 << (3*2));
//
//    // Configure PB0 (Buzzer) as Output
//    GPIOB->MODER &= ~(0b11 << (0*2));
//    GPIOB->MODER |=  (0b01 << (0*2));
//
//    // Configure PB6 (Fan) as Output
//    GPIOB->MODER &= ~(0b11 << (6*2));
//    GPIOB->MODER |=  (0b01 << (6*2));
//
//    // Enable ADC1
//    ADC1->CR2 |= (1<<0);
//
//    for(volatile int i = 0; i < 1000; i++); // Small delay
//
//    // Set ADC Resolution to 12-bit (Default)
//    ADC1->CR1 &= ~(0b11 << 24);
//
//    // Select Channel 0
//    ADC1->SQR3 = 0;
//
//    while(1)
//    {
//        // Start ADC Conversion
//        ADC1->CR2 |= (1<<30);
//
//        // Wait for conversion to complete
//        while(!(ADC1->SR & (1<<1)));
//
//        // Read ADC value
//        int ADC_Read = ADC1->DR;
//        float voltage = (ADC_Read * 3.3f) / 4096.0f;
//        int temp = (int)(voltage / 0.01f);
//
//        // Control LEDs and Fan based on Temperature
//        if(temp <= 25){
//            GPIOA->ODR |= (1<<3);   // Green LED ON
//            GPIOA->ODR &= ~(1<<2);  // Yellow LED OFF
//            GPIOA->ODR &= ~(1<<1);  // Red LED OFF
//            GPIOB->ODR &= ~(1<<6);  // Fan OFF
//            GPIOB->ODR &= ~(1<<0);  // Buzzer OFF
//        }
//        else if(temp > 25 && temp <= 35){
//            GPIOA->ODR &= ~(1<<3);
//            GPIOA->ODR |= (1<<2);
//            GPIOA->ODR &= ~(1<<1);
//            GPIOB->ODR |= (1<<6);
//            GPIOB->ODR &= ~(1<<0);
//        }
//        else if(temp > 35 && temp <= 45){
//            GPIOA->ODR &= ~(1<<3);
//            GPIOA->ODR &= ~(1<<2);
//            GPIOA->ODR |= (1<<1);
//            GPIOB->ODR |= (1<<6);
//            GPIOB->ODR &= ~(1<<0);
//        }
//        else if(temp > 45){
//            GPIOA->ODR &= ~(1<<3);
//            GPIOA->ODR &= ~(1<<2);
//            GPIOA->ODR |= (1<<1);
//            GPIOB->ODR &= ~(1<<6);
//            GPIOB->ODR |= (1<<0);
//        }
//    }
//}
